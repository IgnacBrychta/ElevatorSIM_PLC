#srcfile 'C:\USERS\IGN·C\DOCUMENTS\PLC\WINTER_PLC\07_VYTAH\PRGMAIN.ST'

#defpou VisualizeQueue
  bool __fc__VisualizeQueue,
  int index
#reg VisualizeQueue  __Instance__VisualizeQueue


#defpou EnqueueFloor
  bool __fc__EnqueueFloor,
  int floorToEnqueue,
  int index
#reg EnqueueFloor  __Instance__EnqueueFloor


#defpou EnqueueUpperFloor
  bool __fc__EnqueueUpperFloor,
  int floorToEnqueue,
  int index
#reg EnqueueUpperFloor  __Instance__EnqueueUpperFloor


#defpou EnqueueLowerFloor
  bool __fc__EnqueueLowerFloor,
  int floorToEnqueue,
  int index
#reg EnqueueLowerFloor  __Instance__EnqueueLowerFloor


#defpou EmptyUpperAndLowerQueue
  bool __fc__EmptyUpperAndLowerQueue,
  int index
#reg EmptyUpperAndLowerQueue  __Instance__EmptyUpperAndLowerQueue


#defpou ShiftQueueLeft
  bool __fc__ShiftQueueLeft,
  int index,
  int nextIndex,
  int temp
#reg ShiftQueueLeft  __Instance__ShiftQueueLeft


#defpou DequeueFloor
  int __fc__DequeueFloor,
  int dequeuedFloor
#reg DequeueFloor  __Instance__DequeueFloor


#defpou IsFloorAlreadyEnqueued
  bool __fc__IsFloorAlreadyEnqueued,
  int index,
  int floor
#reg IsFloorAlreadyEnqueued  __Instance__IsFloorAlreadyEnqueued


#defpou IsQueueEmpty
  bool __fc__IsQueueEmpty,
  int index,
  bool empty
#reg IsQueueEmpty  __Instance__IsQueueEmpty


#defpou BubbleSortQueueLower
  bool __fc__BubbleSortQueueLower,
  int i,
  int j,
  int itemLeft,
  int itemRight,
  int temp
#reg BubbleSortQueueLower  __Instance__BubbleSortQueueLower


#defpou BubbleSortQueueUpper
  bool __fc__BubbleSortQueueUpper,
  int i,
  int j,
  int itemLeft,
  int itemRight,
  int temp
#reg BubbleSortQueueUpper  __Instance__BubbleSortQueueUpper


#defpou BubbleSortQueue
  bool __fc__BubbleSortQueue,
  int i,
  int j,
  int itemLeft,
  int itemRight,
  int temp
#reg BubbleSortQueue  __Instance__BubbleSortQueue


#defpou ElevatorSortQueue
  bool __fc__ElevatorSortQueue,
  int index,
  int item,
  int index2,
  int changes
#reg ElevatorSortQueue  __Instance__ElevatorSortQueue


#defpou IsAnyDoorOpened
  bool __fc__IsAnyDoorOpened,
  int index
#reg IsAnyDoorOpened  __Instance__IsAnyDoorOpened


#defpou CloseAllDoors
  bool __fc__CloseAllDoors,
  int index
#reg CloseAllDoors  __Instance__CloseAllDoors


#defpou CloseAllDoorsExceptForArg
  bool __fc__CloseAllDoorsExceptForArg,
  int index,
  int floorDoorToOpen
#reg CloseAllDoorsExceptForArg  __Instance__CloseAllDoorsExceptForArg


#defpou HandleDoors
  bool __fc__HandleDoors
#reg HandleDoors  __Instance__HandleDoors


#defpou ResetAllButtons
  bool __fc__ResetAllButtons,
  int index
#reg ResetAllButtons  __Instance__ResetAllButtons


#defpou HandleFloorSelection
  bool __fc__HandleFloorSelection
#reg HandleFloorSelection  __Instance__HandleFloorSelection


#defpou HandleButtons
  bool __fc__HandleButtons,
  int index
#reg HandleButtons  __Instance__HandleButtons


#defpou HandleMovement
  bool __fc__HandleMovement
#reg HandleMovement  __Instance__HandleMovement


#defpou IsAnyObstaclePresent
  bool __fc__IsAnyObstaclePresent,
  int index
#reg IsAnyObstaclePresent  __Instance__IsAnyObstaclePresent


#defpou HandleStopConditions
  bool __fc__HandleStopConditions
#reg HandleStopConditions  __Instance__HandleStopConditions


#defpou prgMain
  int index,
  int queuedFloor,
  int floorDifference

 
#srcfile 'C:\USERS\IGN·C\DOCUMENTS\PLC\WINTER_PLC\07_VYTAH\PRGMAIN.ST'
#pou VisualizeQueue
#srcline 2 ;FUNCTION VisualizeQueue : BOOL

#struct VisualizeQueue__temp__
  int P0__st__,
  string[82] PS0__st__,
  string[82] PSC__st__
#data byte _str_VisualizeQueue_0 = 
  '',0
#data byte _str_VisualizeQueue_1 = 
  ';',0
P     61
VisualizeQueue_L0:
 LINK __SizeOf(VisualizeQueue__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__VisualizeQueue
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 6 ;  stringQueueRepresentation := '';
 LD   0   ; null string
 LEA  stringQueueRepresentation
 WRI  
 LEA  stringQueueRepresentation
 LD   80
 DST    ; Level 1
 LEA  _str_VisualizeQueue_0
 SCON 
#debug_left string stringQueueRepresentation
 PDST   ; Level 1
#srcline 7 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
VisualizeQueue_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  VisualizeQueue_L2
 DBG  
#srcline 8 ;    stringQueueRepresentation := stringQueueRepresentation + ';' + INT_TO_STRING(queue[index]);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  stringQueueRepresentation
#debug string stringQueueRepresentation
 SCON 
 LEA  _str_VisualizeQueue_1
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   80
 DST    ; Level 2
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 SCNV $0B30;  IEC_INT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEA  stringQueueRepresentation
 WRI  
 LEA  stringQueueRepresentation
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string stringQueueRepresentation
 PDST   ; Level 1
#srcline 9 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  VisualizeQueue_L1
VisualizeQueue_L2:
 NOP  -1
#srcline 10 ;END_FUNCTION
 PRV  
 LDX  __fc__VisualizeQueue
 ULNK
RET
E     61
#endpou 

#pou EnqueueFloor
#srcline 12 ;FUNCTION EnqueueFloor : BOOL

#struct EnqueueFloor__temp__
  int P0__st__
P     61
EnqueueFloor_L0:
 LINK __SizeOf(EnqueueFloor__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__EnqueueFloor
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 20 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
EnqueueFloor_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  EnqueueFloor_L2
 DBG  
#srcline 21 ;    IF queue[index] = queueDefaultValue THEN
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 EQ
 JMC  EnqueueFloor_L3
#srcline 22 ;      queue[index] := floorToEnqueue;
 LDX  floorToEnqueue
#debug int floorToEnqueue
 EXTW 
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index]
#srcline 23 ;      EXIT;//index := 1000; // break
 JMP  EnqueueFloor_L2
#srcline 24 ;    END_IF;
EnqueueFloor_L3:
#srcline 25 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  EnqueueFloor_L1
EnqueueFloor_L2:
 NOP  -1
#srcline 26 ;END_FUNCTION
 PRV  
 LDX  __fc__EnqueueFloor
 ULNK
RET
E     61
#endpou 

#pou EnqueueUpperFloor
#srcline 28 ;FUNCTION EnqueueUpperFloor : BOOL

#struct EnqueueUpperFloor__temp__
  int P0__st__
P     61
EnqueueUpperFloor_L0:
 LINK __SizeOf(EnqueueUpperFloor__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__EnqueueUpperFloor
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 36 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
EnqueueUpperFloor_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  EnqueueUpperFloor_L2
 DBG  
#srcline 37 ;    IF queueUpperFloors[index] = queueDefaultValue THEN
 LEA  queueUpperFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueUpperFloors[index]
 EXTW 
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 EQ
 JMC  EnqueueUpperFloor_L3
#srcline 38 ;      queueUpperFloors[index] := floorToEnqueue;
 LDX  floorToEnqueue
#debug int floorToEnqueue
 EXTW 
 LEA  queueUpperFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueUpperFloors[index]
#srcline 39 ;      EXIT;
 JMP  EnqueueUpperFloor_L2
#srcline 40 ;    END_IF;
EnqueueUpperFloor_L3:
#srcline 41 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  EnqueueUpperFloor_L1
EnqueueUpperFloor_L2:
 NOP  -1
#srcline 42 ;END_FUNCTION
 PRV  
 LDX  __fc__EnqueueUpperFloor
 ULNK
RET
E     61
#endpou 

#pou EnqueueLowerFloor
#srcline 44 ;FUNCTION EnqueueLowerFloor : BOOL

#struct EnqueueLowerFloor__temp__
  int P0__st__
P     61
EnqueueLowerFloor_L0:
 LINK __SizeOf(EnqueueLowerFloor__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__EnqueueLowerFloor
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 52 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
EnqueueLowerFloor_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  EnqueueLowerFloor_L2
 DBG  
#srcline 53 ;    IF queueLowerFloors[index] = queueDefaultValue THEN
 LEA  queueLowerFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueLowerFloors[index]
 EXTW 
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 EQ
 JMC  EnqueueLowerFloor_L3
#srcline 54 ;      queueLowerFloors[index] := floorToEnqueue;
 LDX  floorToEnqueue
#debug int floorToEnqueue
 EXTW 
 LEA  queueLowerFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueLowerFloors[index]
#srcline 55 ;      EXIT;
 JMP  EnqueueLowerFloor_L2
#srcline 56 ;    END_IF;
EnqueueLowerFloor_L3:
#srcline 57 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  EnqueueLowerFloor_L1
EnqueueLowerFloor_L2:
 NOP  -1
#srcline 58 ;END_FUNCTION
 PRV  
 LDX  __fc__EnqueueLowerFloor
 ULNK
RET
E     61
#endpou 

#pou EmptyUpperAndLowerQueue
#srcline 60 ;FUNCTION EmptyUpperAndLowerQueue : BOOL

#struct EmptyUpperAndLowerQueue__temp__
  int P0__st__
P     61
EmptyUpperAndLowerQueue_L0:
 LINK __SizeOf(EmptyUpperAndLowerQueue__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__EmptyUpperAndLowerQueue
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 64 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
EmptyUpperAndLowerQueue_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  EmptyUpperAndLowerQueue_L2
 DBG  
#srcline 65 ;    queueUpperFloors[index] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 LEA  queueUpperFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueUpperFloors[index]
#srcline 66 ;    queueLowerFloors[index] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 LEA  queueLowerFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueLowerFloors[index]
#srcline 67 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  EmptyUpperAndLowerQueue_L1
EmptyUpperAndLowerQueue_L2:
 NOP  -1
#srcline 68 ;END_FUNCTION
 PRV  
 LDX  __fc__EmptyUpperAndLowerQueue
 ULNK
RET
E     61
#endpou 

#pou ShiftQueueLeft
#srcline 70 ;FUNCTION ShiftQueueLeft : BOOL

#struct ShiftQueueLeft__temp__
  int P0__st__
P     61
ShiftQueueLeft_L0:
 LINK __SizeOf(ShiftQueueLeft__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__ShiftQueueLeft
 WRX  index
 WRX  nextIndex
 WRX  temp
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 76 ;  FOR index := 0 TO queueSize - 2 DO // - 2 because not for last element
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P0__st__
ShiftQueueLeft_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  ShiftQueueLeft_L2
 DBG  
#srcline 77 ;    nextIndex := index + 1;
 LDX  index
#debug int index
 EXTW 
 LD   int 1
 ADD
 EXTW
 WRX  nextIndex
#debug_left int nextIndex
#srcline 78 ;    temp := queue[index];
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 WRX  temp
#debug_left int temp
#srcline 79 ;    queue[index] := queue[nextIndex];
 LEA  queue
 LDX  nextIndex
#debug int nextIndex
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[nextIndex]
 EXTW 
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index]
#srcline 80 ;    queue[nextIndex] := temp;
 LDX  temp
#debug int temp
 EXTW 
 LEA  queue
 LDX  nextIndex
#debug int nextIndex
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[nextIndex]
#srcline 81 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  ShiftQueueLeft_L1
ShiftQueueLeft_L2:
 NOP  -1
#srcline 82 ;END_FUNCTION
 PRV  
 LDX  __fc__ShiftQueueLeft
 ULNK
RET
E     61
#endpou 

#pou DequeueFloor
#srcline 86 ;FUNCTION DequeueFloor : INT
P     61
DequeueFloor_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__DequeueFloor
 WRX  dequeuedFloor
; End initialize - variables
#srcline 89 ;  END_VAR;
#srcline 91 ;  dequeuedFloor := queue[0];
 LD   queue[0]
#debug int queue[0]
 EXTW 
 WRX  dequeuedFloor
#debug_left int dequeuedFloor
#srcline 92 ;  queue[0] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 WR   queue[0]
#debug_left int queue[0]
#srcline 93 ;  ShiftQueueLeft();
 LEA  __Instance__ShiftQueueLeft
 CAL  ShiftQueueLeft_L0
#srcline 94 ;  DequeueFloor := dequeuedFloor;
 LDX  dequeuedFloor
#debug int dequeuedFloor
 EXTW 
 WRX  __fc__DequeueFloor
#debug_left int DequeueFloor
#srcline 95 ;END_FUNCTION
 PRV  
 LDX  __fc__DequeueFloor
 EXTW 
 ULNK
RET
E     61
#endpou 

#pou IsFloorAlreadyEnqueued
#srcline 97 ;FUNCTION IsFloorAlreadyEnqueued : BOOL

#struct IsFloorAlreadyEnqueued__temp__
  int P0__st__
P     61
IsFloorAlreadyEnqueued_L0:
 LINK __SizeOf(IsFloorAlreadyEnqueued__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__IsFloorAlreadyEnqueued
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 105 ;  IsFloorAlreadyEnqueued := FALSE;
 LD   bool 0       ; false
 WRX  __fc__IsFloorAlreadyEnqueued
#debug_left bool IsFloorAlreadyEnqueued
#srcline 106 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
IsFloorAlreadyEnqueued_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  IsFloorAlreadyEnqueued_L2
 DBG  
#srcline 107 ;    IF queue[index] = floor THEN
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 LDX  floor
#debug int floor
 EXTW 
 EQ
 JMC  IsFloorAlreadyEnqueued_L3
#srcline 108 ;      IsFloorAlreadyEnqueued := TRUE;
 LD   bool -1       ; true
 WRX  __fc__IsFloorAlreadyEnqueued
#debug_left bool IsFloorAlreadyEnqueued
#srcline 109 ;      EXIT;
 JMP  IsFloorAlreadyEnqueued_L2
#srcline 110 ;    END_IF;
IsFloorAlreadyEnqueued_L3:
#srcline 111 ;  END_FOR; 
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  IsFloorAlreadyEnqueued_L1
IsFloorAlreadyEnqueued_L2:
 NOP  -1
#srcline 112 ;END_FUNCTION
 PRV  
 LDX  __fc__IsFloorAlreadyEnqueued
 ULNK
RET
E     61
#endpou 

#pou IsQueueEmpty
#srcline 114 ;FUNCTION IsQueueEmpty : BOOL

#struct IsQueueEmpty__temp__
  int P0__st__
P     61
IsQueueEmpty_L0:
 LINK __SizeOf(IsQueueEmpty__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__IsQueueEmpty
 WRX  index
 LD   bool -1   ; true
 WRX  empty
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 119 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
IsQueueEmpty_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  IsQueueEmpty_L2
 DBG  
#srcline 120 ;    IF NOT queue[index] = queueDefaultValue THEN
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 EQ
 NEG
 JMC  IsQueueEmpty_L3
#srcline 121 ;      empty := FALSE;
 LD   bool 0       ; false
 WRX  empty
#debug_left bool empty
#srcline 122 ;      index := 1000;
 LD   int 1000
 WRX  index
#debug_left int index
#srcline 123 ;    END_IF; 
IsQueueEmpty_L3:
#srcline 124 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  IsQueueEmpty_L1
IsQueueEmpty_L2:
 NOP  -1
#srcline 125 ;  IsQueueEmpty := empty;
 LDX  empty
#debug bool empty
 WRX  __fc__IsQueueEmpty
#debug_left bool IsQueueEmpty
#srcline 126 ;END_FUNCTION
 PRV  
 LDX  __fc__IsQueueEmpty
 ULNK
RET
E     61
#endpou 

#pou BubbleSortQueueLower
#srcline 128 ;FUNCTION BubbleSortQueueLower : BOOL

#struct BubbleSortQueueLower__temp__
  int P0__st__,
  int P1__st__
P     61
BubbleSortQueueLower_L0:
 LINK __SizeOf(BubbleSortQueueLower__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__BubbleSortQueueLower
 WRX  i
 WRX  j
 WRX  itemLeft
 WRX  itemRight
 WRX  temp
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 136 ;  FOR i := 0 TO queueSize - 2 DO
 LD   int 0
 WRX  i
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P0__st__
BubbleSortQueueLower_L1:
 LDX  i
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  BubbleSortQueueLower_L2
 DBG  
#srcline 137 ;    FOR j := 0 TO queueSize - 2 DO
 LD   int 0
 WRX  j
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P1__st__
BubbleSortQueueLower_L3:
 LDX  j
 EXTW 
 LDY  P1__st__
 EXTW 
 GTS  
 JMD  BubbleSortQueueLower_L4
 DBG  
#srcline 138 ;      itemLeft := queueLowerFloors[j];
 LEA  queueLowerFloors
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueLowerFloors[j]
 EXTW 
 WRX  itemLeft
#debug_left int itemLeft
#srcline 139 ;      itemRight := queueLowerFloors[j + 1];
 LEA  queueLowerFloors
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueLowerFloors[j+1]
 EXTW 
 WRX  itemRight
#debug_left int itemRight
#srcline 140 ;      IF itemLeft < itemRight THEN
 LDX  itemLeft
#debug int itemLeft
 EXTW 
 LDX  itemRight
#debug int itemRight
 EXTW 
 LTS
 JMC  BubbleSortQueueLower_L5
#srcline 141 ;        temp := queueLowerFloors[j];
 LEA  queueLowerFloors
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueLowerFloors[j]
 EXTW 
 WRX  temp
#debug_left int temp
#srcline 142 ;        queueLowerFloors[j] := queueLowerFloors[j + 1];
 LEA  queueLowerFloors
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueLowerFloors[j+1]
 EXTW 
 LEA  queueLowerFloors
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueLowerFloors[j]
#srcline 143 ;        queueLowerFloors[j + 1] := temp;
 LDX  temp
#debug int temp
 EXTW 
 LEA  queueLowerFloors
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueLowerFloors[j+1]
#srcline 144 ;      END_IF;
BubbleSortQueueLower_L5:
#srcline 145 ;    END_FOR;
 LDX  j
 LD   1
 ADD  
 EXTW 
 WRX  j
 JMP  BubbleSortQueueLower_L3
BubbleSortQueueLower_L4:
 NOP  -1
#srcline 146 ;  END_FOR;
 LDX  i
 LD   1
 ADD  
 EXTW 
 WRX  i
 JMP  BubbleSortQueueLower_L1
BubbleSortQueueLower_L2:
 NOP  -1
#srcline 147 ;END_FUNCTION
 PRV  
 LDX  __fc__BubbleSortQueueLower
 ULNK
RET
E     61
#endpou 

#pou BubbleSortQueueUpper
#srcline 149 ;FUNCTION BubbleSortQueueUpper : BOOL

#struct BubbleSortQueueUpper__temp__
  int P0__st__,
  int P1__st__
P     61
BubbleSortQueueUpper_L0:
 LINK __SizeOf(BubbleSortQueueUpper__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__BubbleSortQueueUpper
 WRX  i
 WRX  j
 WRX  itemLeft
 WRX  itemRight
 WRX  temp
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 157 ;  FOR i := 0 TO queueSize - 2 DO
 LD   int 0
 WRX  i
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P0__st__
BubbleSortQueueUpper_L1:
 LDX  i
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  BubbleSortQueueUpper_L2
 DBG  
#srcline 158 ;    FOR j := 0 TO queueSize - 2 DO
 LD   int 0
 WRX  j
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P1__st__
BubbleSortQueueUpper_L3:
 LDX  j
 EXTW 
 LDY  P1__st__
 EXTW 
 GTS  
 JMD  BubbleSortQueueUpper_L4
 DBG  
#srcline 159 ;      itemLeft := queueUpperFloors[j];
 LEA  queueUpperFloors
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueUpperFloors[j]
 EXTW 
 WRX  itemLeft
#debug_left int itemLeft
#srcline 160 ;      itemRight := queueUpperFloors[j + 1];
 LEA  queueUpperFloors
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueUpperFloors[j+1]
 EXTW 
 WRX  itemRight
#debug_left int itemRight
#srcline 161 ;      IF itemLeft < itemRight THEN
 LDX  itemLeft
#debug int itemLeft
 EXTW 
 LDX  itemRight
#debug int itemRight
 EXTW 
 LTS
 JMC  BubbleSortQueueUpper_L5
#srcline 162 ;        temp := queueUpperFloors[j];
 LEA  queueUpperFloors
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueUpperFloors[j]
 EXTW 
 WRX  temp
#debug_left int temp
#srcline 163 ;        queueUpperFloors[j] := queueUpperFloors[j + 1];
 LEA  queueUpperFloors
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueUpperFloors[j+1]
 EXTW 
 LEA  queueUpperFloors
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueUpperFloors[j]
#srcline 164 ;        queueUpperFloors[j + 1] := temp;
 LDX  temp
#debug int temp
 EXTW 
 LEA  queueUpperFloors
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueUpperFloors[j+1]
#srcline 165 ;      END_IF;
BubbleSortQueueUpper_L5:
#srcline 166 ;    END_FOR;
 LDX  j
 LD   1
 ADD  
 EXTW 
 WRX  j
 JMP  BubbleSortQueueUpper_L3
BubbleSortQueueUpper_L4:
 NOP  -1
#srcline 167 ;  END_FOR;
 LDX  i
 LD   1
 ADD  
 EXTW 
 WRX  i
 JMP  BubbleSortQueueUpper_L1
BubbleSortQueueUpper_L2:
 NOP  -1
#srcline 168 ;END_FUNCTION
 PRV  
 LDX  __fc__BubbleSortQueueUpper
 ULNK
RET
E     61
#endpou 

#pou BubbleSortQueue
#srcline 170 ;FUNCTION BubbleSortQueue : BOOL

#struct BubbleSortQueue__temp__
  int P0__st__,
  int P1__st__
P     61
BubbleSortQueue_L0:
 LINK __SizeOf(BubbleSortQueue__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__BubbleSortQueue
 WRX  i
 WRX  j
 WRX  itemLeft
 WRX  itemRight
 WRX  temp
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 178 ;  FOR i := 0 TO queueSize - 2 DO
 LD   int 0
 WRX  i
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P0__st__
BubbleSortQueue_L1:
 LDX  i
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  BubbleSortQueue_L2
 DBG  
#srcline 179 ;    FOR j := 0 TO queueSize - 2 DO
 LD   int 0
 WRX  j
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P1__st__
BubbleSortQueue_L3:
 LDX  j
 EXTW 
 LDY  P1__st__
 EXTW 
 GTS  
 JMD  BubbleSortQueue_L4
 DBG  
#srcline 180 ;      itemLeft := queue[j];
 LEA  queue
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[j]
 EXTW 
 WRX  itemLeft
#debug_left int itemLeft
#srcline 181 ;      itemRight := queue[j + 1];
 LEA  queue
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[j+1]
 EXTW 
 WRX  itemRight
#debug_left int itemRight
#srcline 182 ;      IF itemLeft < itemRight THEN
 LDX  itemLeft
#debug int itemLeft
 EXTW 
 LDX  itemRight
#debug int itemRight
 EXTW 
 LTS
 JMC  BubbleSortQueue_L5
#srcline 183 ;        temp := queue[j];
 LEA  queue
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[j]
 EXTW 
 WRX  temp
#debug_left int temp
#srcline 184 ;        queue[j] := queue[j + 1];
 LEA  queue
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[j+1]
 EXTW 
 LEA  queue
 LDX  j
#debug int j
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[j]
#srcline 185 ;        queue[j + 1] := temp;
 LDX  temp
#debug int temp
 EXTW 
 LEA  queue
 LDX  j
#debug int j
 EXTW 
 LD   int 1
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[j+1]
#srcline 186 ;      END_IF;
BubbleSortQueue_L5:
#srcline 187 ;    END_FOR;
 LDX  j
 LD   1
 ADD  
 EXTW 
 WRX  j
 JMP  BubbleSortQueue_L3
BubbleSortQueue_L4:
 NOP  -1
#srcline 188 ;  END_FOR;
 LDX  i
 LD   1
 ADD  
 EXTW 
 WRX  i
 JMP  BubbleSortQueue_L1
BubbleSortQueue_L2:
 NOP  -1
#srcline 189 ;END_FUNCTION
 PRV  
 LDX  __fc__BubbleSortQueue
 ULNK
RET
E     61
#endpou 

#pou ElevatorSortQueue
#srcline 191 ;FUNCTION ElevatorSortQueue : BOOL

#struct ElevatorSortQueue__temp__
  int P0__st__,
  int P1__st__,
  int P2__st__
P     61
ElevatorSortQueue_L0:
 LINK __SizeOf(ElevatorSortQueue__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__ElevatorSortQueue
 WRX  index
 WRX  item
 WRX  index2
 LD   int 0
 WRX  changes
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 198 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
ElevatorSortQueue_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  ElevatorSortQueue_L2
 DBG  
#srcline 199 ;    item := queue[index];
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 WRX  item
#debug_left int item
#srcline 200 ;    IF item > elevatorFloorStart THEN
 LDX  item
#debug int item
 EXTW 
 LD   elevatorFloorStart
#debug int elevatorFloorStart
 EXTW 
 GTS
 JMC  ElevatorSortQueue_L3
#srcline 201 ;      EnqueueUpperFloor(item);
 NXT
 LDX  item
#debug int item
 EXTW 
 WR   __Instance__EnqueueUpperFloor~floorToEnqueue
#debug_left int __Instance__EnqueueUpperFloor~floorToEnqueue
 PRV
 LEA  __Instance__EnqueueUpperFloor
 CAL  EnqueueUpperFloor_L0
#srcline 202 ;    ELSIF item < elevatorFloorStart THEN
 JMP  ElevatorSortQueue_L4
ElevatorSortQueue_L3:
 LDX  item
#debug int item
 EXTW 
 LD   elevatorFloorStart
#debug int elevatorFloorStart
 EXTW 
 LTS
 JMC  ElevatorSortQueue_L5
#srcline 203 ;      EnqueueLowerFloor(item);
 NXT
 LDX  item
#debug int item
 EXTW 
 WR   __Instance__EnqueueLowerFloor~floorToEnqueue
#debug_left int __Instance__EnqueueLowerFloor~floorToEnqueue
 PRV
 LEA  __Instance__EnqueueLowerFloor
 CAL  EnqueueLowerFloor_L0
#srcline 204 ;    END_IF;
 JMP  ElevatorSortQueue_L4
ElevatorSortQueue_L5:
ElevatorSortQueue_L4:
#srcline 205 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  ElevatorSortQueue_L1
ElevatorSortQueue_L2:
 NOP  -1
#srcline 207 ;  IF sortLowerFloors THEN BubbleSortQueueLower(); END_IF;
 LD   sortLowerFloors
#debug bool sortLowerFloors
 JMC  ElevatorSortQueue_L6
 LEA  __Instance__BubbleSortQueueLower
 CAL  BubbleSortQueueLower_L0
ElevatorSortQueue_L6:
#srcline 208 ;  IF sortUpperFloors THEN BubbleSortQueueUpper(); END_IF;
 LD   sortUpperFloors
#debug bool sortUpperFloors
 JMC  ElevatorSortQueue_L8
 LEA  __Instance__BubbleSortQueueUpper
 CAL  BubbleSortQueueUpper_L0
ElevatorSortQueue_L8:
#srcline 210 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P1__st__
ElevatorSortQueue_L10:
 LDX  index
 EXTW 
 LDY  P1__st__
 EXTW 
 GTS  
 JMD  ElevatorSortQueue_L11
 DBG  
#srcline 211 ;    item := queueLowerFloors[index];
 LEA  queueLowerFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueLowerFloors[index]
 EXTW 
 WRX  item
#debug_left int item
#srcline 212 ;    IF NOT item = queueDefaultValue THEN
 LDX  item
#debug int item
 EXTW 
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 EQ
 NEG
 JMC  ElevatorSortQueue_L12
#srcline 213 ;      queue[index] := item;
 LDX  item
#debug int item
 EXTW 
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index]
#srcline 214 ;      changes := changes + 1;
 LDX  changes
#debug int changes
 EXTW 
 LD   int 1
 ADD
 EXTW
 WRX  changes
#debug_left int changes
#srcline 215 ;    ELSE      
 JMP  ElevatorSortQueue_L13
ElevatorSortQueue_L12:
#srcline 216 ;      EXIT;
 JMP  ElevatorSortQueue_L11
#srcline 217 ;    END_IF;
ElevatorSortQueue_L13:
#srcline 218 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  ElevatorSortQueue_L10
ElevatorSortQueue_L11:
 NOP  -1
#srcline 220 ;  FOR index2 := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index2
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P2__st__
ElevatorSortQueue_L14:
 LDX  index2
 EXTW 
 LDY  P2__st__
 EXTW 
 GTS  
 JMD  ElevatorSortQueue_L15
 DBG  
#srcline 221 ;    item := queueUpperFloors[index2];
 LEA  queueUpperFloors
 LDX  index2
#debug int index2
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queueUpperFloors[index2]
 EXTW 
 WRX  item
#debug_left int item
#srcline 222 ;    IF NOT item = queueDefaultValue THEN
 LDX  item
#debug int item
 EXTW 
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 EQ
 NEG
 JMC  ElevatorSortQueue_L16
#srcline 223 ;      queue[index2 + changes] := item;
 LDX  item
#debug int item
 EXTW 
 LEA  queue
 LDX  index2
#debug int index2
 EXTW 
 LDX  changes
#debug int changes
 EXTW 
 ADD
 EXTW
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index2+changes]
#srcline 224 ;    ELSE
 JMP  ElevatorSortQueue_L17
ElevatorSortQueue_L16:
#srcline 225 ;      EXIT;
 JMP  ElevatorSortQueue_L15
#srcline 226 ;    END_IF;
ElevatorSortQueue_L17:
#srcline 227 ;  END_FOR;
 LDX  index2
 LD   1
 ADD  
 EXTW 
 WRX  index2
 JMP  ElevatorSortQueue_L14
ElevatorSortQueue_L15:
 NOP  -1
#srcline 228 ;  EmptyUpperAndLowerQueue();
 LEA  __Instance__EmptyUpperAndLowerQueue
 CAL  EmptyUpperAndLowerQueue_L0
#srcline 229 ;END_FUNCTION
 PRV  
 LDX  __fc__ElevatorSortQueue
 ULNK
RET
E     61
#endpou 

#pou IsAnyDoorOpened
#srcline 233 ;FUNCTION IsAnyDoorOpened : BOOL

#struct IsAnyDoorOpened__temp__
  int P0__st__
P     61
IsAnyDoorOpened_L0:
 LINK __SizeOf(IsAnyDoorOpened__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__IsAnyDoorOpened
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 237 ;  IsAnyDoorOpened := FALSE;
 LD   bool 0       ; false
 WRX  __fc__IsAnyDoorOpened
#debug_left bool IsAnyDoorOpened
#srcline 238 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
IsAnyDoorOpened_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  IsAnyDoorOpened_L2
 DBG  
#srcline 239 ;    IF elevatorDoorsOpened[index] THEN
 LEA  elevatorDoorsOpened
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 LDIB 
#debug bool elevatorDoorsOpened[index]
 JMC  IsAnyDoorOpened_L3
#srcline 240 ;      IsAnyDoorOpened := TRUE;
 LD   bool -1       ; true
 WRX  __fc__IsAnyDoorOpened
#debug_left bool IsAnyDoorOpened
#srcline 241 ;      EXIT;
 JMP  IsAnyDoorOpened_L2
#srcline 242 ;    END_IF;
IsAnyDoorOpened_L3:
#srcline 243 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  IsAnyDoorOpened_L1
IsAnyDoorOpened_L2:
 NOP  -1
#srcline 244 ;END_FUNCTION
 PRV  
 LDX  __fc__IsAnyDoorOpened
 ULNK
RET
E     61
#endpou 

#pou CloseAllDoors
#srcline 246 ;FUNCTION CloseAllDoors : BOOL

#struct CloseAllDoors__temp__
  int P0__st__
P     61
CloseAllDoors_L0:
 LINK __SizeOf(CloseAllDoors__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__CloseAllDoors
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 250 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
CloseAllDoors_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  CloseAllDoors_L2
 DBG  
#srcline 251 ;    elevatorDoorsOpened[index] := FALSE;
 LD   bool 0       ; false
 LEA  elevatorDoorsOpened
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[index]
#srcline 252 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  CloseAllDoors_L1
CloseAllDoors_L2:
 NOP  -1
#srcline 253 ;END_FUNCTION
 PRV  
 LDX  __fc__CloseAllDoors
 ULNK
RET
E     61
#endpou 

#pou CloseAllDoorsExceptForArg
#srcline 255 ;FUNCTION CloseAllDoorsExceptForArg : BOOL

#struct CloseAllDoorsExceptForArg__temp__
  int P0__st__
P     61
CloseAllDoorsExceptForArg_L0:
 LINK __SizeOf(CloseAllDoorsExceptForArg__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__CloseAllDoorsExceptForArg
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 262 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
CloseAllDoorsExceptForArg_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  CloseAllDoorsExceptForArg_L2
 DBG  
#srcline 263 ;    IF index = floorDoorToOpen THEN
 LDX  index
#debug int index
 EXTW 
 LDX  floorDoorToOpen
#debug int floorDoorToOpen
 EXTW 
 EQ
 JMC  CloseAllDoorsExceptForArg_L3
#srcline 264 ;      elevatorDoorsOpened[index] := TRUE;
 LD   bool -1       ; true
 LEA  elevatorDoorsOpened
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[index]
#srcline 265 ;    ELSE
 JMP  CloseAllDoorsExceptForArg_L4
CloseAllDoorsExceptForArg_L3:
#srcline 266 ;      elevatorDoorsOpened[index] := FALSE;
 LD   bool 0       ; false
 LEA  elevatorDoorsOpened
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[index]
#srcline 267 ;    END_IF;
CloseAllDoorsExceptForArg_L4:
#srcline 268 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  CloseAllDoorsExceptForArg_L1
CloseAllDoorsExceptForArg_L2:
 NOP  -1
#srcline 269 ;END_FUNCTION
 PRV  
 LDX  __fc__CloseAllDoorsExceptForArg
 ULNK
RET
E     61
#endpou 

#pou HandleDoors
#srcline 271 ;FUNCTION HandleDoors : BOOL
P     61
HandleDoors_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleDoors
; End initialize - variables
#srcline 272 ;  IF forceOpenCurrentElevatorFloorDoor OR stopSignActivated THEN
 LD   forceOpenCurrentElevatorFloorDoor
#debug bool forceOpenCurrentElevatorFloorDoor
 LD   stopSignActivated
#debug bool stopSignActivated
 OR  
 JMC  HandleDoors_L1
#srcline 273 ;    elevatorDoorsOpened[elevatorFloor] := TRUE;
 LD   bool -1       ; true
 LEA  elevatorDoorsOpened
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[elevatorFloor]
#srcline 274 ;  ELSIF elevatorDirection = 0 THEN
 JMP  HandleDoors_L2
HandleDoors_L1:
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int 0
 EQ
 JMC  HandleDoors_L3
#srcline 275 ;    // open doors of the floor the elevator is at
#srcline 276 ;    CloseAllDoorsExceptForArg(elevatorFloor);
 NXT
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 WR   __Instance__CloseAllDoorsExceptForArg~floorDoorToOpen
#debug_left int __Instance__CloseAllDoorsExceptForArg~floorDoorToOpen
 PRV
 LEA  __Instance__CloseAllDoorsExceptForArg
 CAL  CloseAllDoorsExceptForArg_L0
#srcline 277 ;  ELSE
 JMP  HandleDoors_L2
HandleDoors_L3:
#srcline 278 ;    CloseAllDoors();
 LEA  __Instance__CloseAllDoors
 CAL  CloseAllDoors_L0
#srcline 279 ;  END_IF;
HandleDoors_L2:
#srcline 280 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleDoors
 ULNK
RET
E     61
#endpou 

#pou ResetAllButtons
#srcline 282 ;FUNCTION ResetAllButtons : BOOL

#struct ResetAllButtons__temp__
  int P0__st__
P     61
ResetAllButtons_L0:
 LINK __SizeOf(ResetAllButtons__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__ResetAllButtons
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 286 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
ResetAllButtons_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  ResetAllButtons_L2
 DBG  
#srcline 287 ;    elevatorButtonsPressed[index] := FALSE;
 LD   bool 0       ; false
 LEA  elevatorButtonsPressed
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorButtonsPressed[index]
#srcline 288 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  ResetAllButtons_L1
ResetAllButtons_L2:
 NOP  -1
#srcline 289 ;END_FUNCTION
 PRV  
 LDX  __fc__ResetAllButtons
 ULNK
RET
E     61
#endpou 

#pou HandleFloorSelection
#srcline 291 ;FUNCTION HandleFloorSelection : BOOL

#struct HandleFloorSelection__temp__
  string[82] PS0__st__,
  string[82] PSC__st__
P     61
HandleFloorSelection_L0:
 LINK __SizeOf(HandleFloorSelection__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleFloorSelection
; End initialize - variables
#srcline 292 ;  IF NOT elevatorFloor = targetFloor AND NOT IsFloorAlreadyEnqueued(targetFloor) THEN
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 LD   targetFloor
#debug int targetFloor
 EXTW 
 EQ
 NEG
 NXT
 LD   targetFloor
#debug int targetFloor
 EXTW 
 WR   __Instance__IsFloorAlreadyEnqueued~floor
#debug_left int __Instance__IsFloorAlreadyEnqueued~floor
 PRV
 LEA  __Instance__IsFloorAlreadyEnqueued
 CAL  IsFloorAlreadyEnqueued_L0
 NEG
 AND
 JMC  HandleFloorSelection_L1
#srcline 293 ;    EnqueueFloor(targetFloor);
 NXT
 LD   targetFloor
#debug int targetFloor
 EXTW 
 WR   __Instance__EnqueueFloor~floorToEnqueue
#debug_left int __Instance__EnqueueFloor~floorToEnqueue
 PRV
 LEA  __Instance__EnqueueFloor
 CAL  EnqueueFloor_L0
#srcline 294 ;    floorSetAsElevStop[targetFloor] := TRUE;
 LD   bool -1       ; true
 LEA  floorSetAsElevStop
 LD   targetFloor
#debug int targetFloor
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool floorSetAsElevStop[targetFloor]
#srcline 295 ;    pressedButtonsQueueDebug := pressedButtonsQueueDebug + INT_TO_STRING(targetFloor);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  pressedButtonsQueueDebug
#debug string pressedButtonsQueueDebug
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   80
 DST    ; Level 2
 LD   targetFloor
#debug int targetFloor
 EXTW 
 SCNV $0B30;  IEC_INT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEA  pressedButtonsQueueDebug
 WRI  
 LEA  pressedButtonsQueueDebug
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string pressedButtonsQueueDebug
 PDST   ; Level 1
#srcline 296 ;  ELSE
 JMP  HandleFloorSelection_L2
HandleFloorSelection_L1:
#srcline 297 ;    elevatorDirectionIndicator := 1;
 LD   int 1
 WR   elevatorDirectionIndicator
#debug_left int elevatorDirectionIndicator
#srcline 298 ;  END_IF;
HandleFloorSelection_L2:
#srcline 299 ;  
#srcline 300 ;  ResetAllButtons();
 LEA  __Instance__ResetAllButtons
 CAL  ResetAllButtons_L0
#srcline 301 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleFloorSelection
 ULNK
RET
E     61
#endpou 

#pou HandleButtons
#srcline 303 ;FUNCTION HandleButtons : BOOL

#struct HandleButtons__temp__
  int P0__st__
P     61
HandleButtons_L0:
 LINK __SizeOf(HandleButtons__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleButtons
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 308 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
HandleButtons_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  HandleButtons_L2
 DBG  
#srcline 309 ;    IF elevatorButtonsPressed[index] THEN
 LEA  elevatorButtonsPressed
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 LDIB 
#debug bool elevatorButtonsPressed[index]
 JMC  HandleButtons_L3
#srcline 310 ;      targetFloor := index;
 LDX  index
#debug int index
 EXTW 
 WR   targetFloor
#debug_left int targetFloor
#srcline 311 ;      HandleFloorSelection();
 LEA  __Instance__HandleFloorSelection
 CAL  HandleFloorSelection_L0
#srcline 312 ;    END_IF;
HandleButtons_L3:
#srcline 313 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  HandleButtons_L1
HandleButtons_L2:
 NOP  -1
#srcline 314 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleButtons
 ULNK
RET
E     61
#endpou 

#pou HandleMovement
#srcline 316 ;FUNCTION HandleMovement : BOOL  
P     61
HandleMovement_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleMovement
; End initialize - variables
#srcline 317 ;  IF NOT stopSignActivated THEN
 LD   stopSignActivated
#debug bool stopSignActivated
 NEG
 JMC  HandleMovement_L1
#srcline 318 ;    IF NOT queue[0] = elevatorFloor THEN
 LD   queue[0]
#debug int queue[0]
 EXTW 
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 EQ
 NEG
 JMC  HandleMovement_L3
#srcline 319 ;      IF elevatorDirection = -1 THEN
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int -1
 EQ
 JMC  HandleMovement_L5
#srcline 320 ;        elevatorFloor := elevatorFloor - 1;
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WR   elevatorFloor
#debug_left int elevatorFloor
#srcline 321 ;      ELSIF elevatorDirection = 1 THEN
 JMP  HandleMovement_L6
HandleMovement_L5:
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int 1
 EQ
 JMC  HandleMovement_L7
#srcline 322 ;        elevatorFloor := elevatorFloor + 1;
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 LD   int 1
 ADD
 EXTW
 WR   elevatorFloor
#debug_left int elevatorFloor
#srcline 323 ;      END_IF;
 JMP  HandleMovement_L6
HandleMovement_L7:
HandleMovement_L6:
#srcline 324 ;      HandleMovement := FALSE;
 LD   bool 0       ; false
 WRX  __fc__HandleMovement
#debug_left bool HandleMovement
#srcline 325 ;    ELSE 
 JMP  HandleMovement_L4
HandleMovement_L3:
#srcline 326 ;      floorSetAsElevStop[elevatorFloor] := FALSE;
 LD   bool 0       ; false
 LEA  floorSetAsElevStop
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool floorSetAsElevStop[elevatorFloor]
#srcline 327 ;      queue[0] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 WR   queue[0]
#debug_left int queue[0]
#srcline 328 ;      ShiftQueueLeft();
 LEA  __Instance__ShiftQueueLeft
 CAL  ShiftQueueLeft_L0
#srcline 329 ;      elevatorDirection := 0;
 LD   int 0
 WR   elevatorDirection
#debug_left int elevatorDirection
#srcline 330 ;      HandleMovement := TRUE; // floor stop
 LD   bool -1       ; true
 WRX  __fc__HandleMovement
#debug_left bool HandleMovement
#srcline 331 ;    END_IF;
HandleMovement_L4:
#srcline 332 ;  ELSE
 JMP  HandleMovement_L2
HandleMovement_L1:
#srcline 333 ;    // obstacle detected, wait for doors
#srcline 334 ;    HandleMovement := TRUE;
 LD   bool -1       ; true
 WRX  __fc__HandleMovement
#debug_left bool HandleMovement
#srcline 335 ;  END_IF; 
HandleMovement_L2:
#srcline 336 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleMovement
 ULNK
RET
E     61
#endpou 

#pou IsAnyObstaclePresent
#srcline 338 ;FUNCTION IsAnyObstaclePresent : BOOL

#struct IsAnyObstaclePresent__temp__
  int P0__st__
P     61
IsAnyObstaclePresent_L0:
 LINK __SizeOf(IsAnyObstaclePresent__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__IsAnyObstaclePresent
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 343 ;  anyObstacleDetected := FALSE;
 LD   bool 0       ; false
 WR   anyObstacleDetected
#debug_left bool anyObstacleDetected
#srcline 344 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
IsAnyObstaclePresent_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  IsAnyObstaclePresent_L2
 DBG  
#srcline 345 ;    IF obstaclesBlockingDoors[index] OR obstacleElevator THEN
 LEA  obstaclesBlockingDoors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 LDIB 
#debug bool obstaclesBlockingDoors[index]
 LD   obstacleElevator
#debug bool obstacleElevator
 OR  
 JMC  IsAnyObstaclePresent_L3
#srcline 346 ;      anyObstacleDetected := TRUE;
 LD   bool -1       ; true
 WR   anyObstacleDetected
#debug_left bool anyObstacleDetected
#srcline 347 ;    END_IF;
IsAnyObstaclePresent_L3:
#srcline 348 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  IsAnyObstaclePresent_L1
IsAnyObstaclePresent_L2:
 NOP  -1
#srcline 349 ;END_FUNCTION
 PRV  
 LDX  __fc__IsAnyObstaclePresent
 ULNK
RET
E     61
#endpou 

#pou HandleStopConditions
#srcline 351 ;FUNCTION HandleStopConditions : BOOL
P     61
HandleStopConditions_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleStopConditions
; End initialize - variables
#srcline 352 ;  stopSignActivated := 
#srcline 353 ;    anyObstacleDetected 
#srcline 354 ;    OR elevatorButtonStopPressed
 LD   anyObstacleDetected
#debug bool anyObstacleDetected
#srcline 355 ;    OR elevatorWeight > elevatorMaximumWeight;
 LD   elevatorButtonStopPressed
#debug bool elevatorButtonStopPressed
 OR  
 LD   elevatorWeight
#debug int elevatorWeight
 EXTW 
 LD   elevatorMaximumWeight
#debug int elevatorMaximumWeight
 EXTW 
 GTS
 OR  
 WR   stopSignActivated
#debug_left bool stopSignActivated
#srcline 356 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleStopConditions
 ULNK
RET
E     61
#endpou 

#pou prgMain
#srcline 358 ;PROGRAM prgMain

#struct prgMain__temp__
  int P0__st__,
  dint P1__st__
P     61
prgMain_L0:
 LINK __SizeOf(prgMain__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 372 ;  IF NOT configured THEN
 LD   configured
#debug bool configured
 NEG
 JMC  prgMain_L1
#srcline 373 ;    FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
prgMain_L3:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  prgMain_L4
 DBG  
#srcline 374 ;      queue[index] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index]
#srcline 375 ;      queueLowerFloors[index] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 LEA  queueLowerFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueLowerFloors[index]
#srcline 376 ;      queueUpperFloors[index] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 LEA  queueUpperFloors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queueUpperFloors[index]
#srcline 377 ;    END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  prgMain_L3
prgMain_L4:
 NOP  -1
#srcline 378 ;    elevatorDoorsOpened[elevatorFloor] := TRUE;
 LD   bool -1       ; true
 LEA  elevatorDoorsOpened
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[elevatorFloor]
#srcline 379 ;    configured := TRUE;
 LD   bool -1       ; true
 WR   configured
#debug_left bool configured
#srcline 380 ;  END_IF;
prgMain_L1:
#srcline 382 ;  IsAnyObstaclePresent();
 LEA  __Instance__IsAnyObstaclePresent
 CAL  IsAnyObstaclePresent_L0
#srcline 383 ;  HandleStopConditions();
 LEA  __Instance__HandleStopConditions
 CAL  HandleStopConditions_L0
#srcline 384 ;  HandleButtons();
 LEA  __Instance__HandleButtons
 CAL  HandleButtons_L0
#srcline 385 ;  IF NOT IsQueueEmpty() THEN
 LEA  __Instance__IsQueueEmpty
 CAL  IsQueueEmpty_L0
 NEG
 JMC  prgMain_L5
#srcline 386 ;    // store movement start floor - for queue sorting (option 2)
#srcline 387 ;    IF elevatorDirection = 0 THEN
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int 0
 EQ
 JMC  prgMain_L7
#srcline 388 ;      elevatorFloorStart := elevatorFloor;
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 WR   elevatorFloorStart
#debug_left int elevatorFloorStart
#srcline 389 ;    END_IF;
prgMain_L7:
#srcline 391 ;    IF selectedSortOption = 1 THEN BubbleSortQueue();
 LD   selectedSortOption
#debug int selectedSortOption
 EXTW 
 LD   int 1
 EQ
 JMC  prgMain_L9
 LEA  __Instance__BubbleSortQueue
 CAL  BubbleSortQueue_L0
#srcline 392 ;    ELSIF selectedSortOption = 2 THEN ElevatorSortQueue();
 JMP  prgMain_L10
prgMain_L9:
 LD   selectedSortOption
#debug int selectedSortOption
 EXTW 
 LD   int 2
 EQ
 JMC  prgMain_L11
 LEA  __Instance__ElevatorSortQueue
 CAL  ElevatorSortQueue_L0
#srcline 393 ;    END_IF;
 JMP  prgMain_L10
prgMain_L11:
prgMain_L10:
#srcline 394 ;    queuedFloor := queue[0];
 LD   queue[0]
#debug int queue[0]
 EXTW 
 WRX  queuedFloor
#debug_left int queuedFloor
#srcline 395 ;    floorDifference := elevatorFloor - queuedFloor;
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 LDX  queuedFloor
#debug int queuedFloor
 EXTW 
 SUB
 EXTW
 WRX  floorDifference
#debug_left int floorDifference
#srcline 396 ;    IF floorDifference > 0 THEN
 LDX  floorDifference
#debug int floorDifference
 EXTW 
 LD   int 0
 GTS
 JMC  prgMain_L12
#srcline 397 ;      elevatorDirection := -1;
 LD   int -1
 WR   elevatorDirection
#debug_left int elevatorDirection
#srcline 398 ;    ELSE
 JMP  prgMain_L13
prgMain_L12:
#srcline 399 ;      elevatorDirection := 1;
 LD   int 1
 WR   elevatorDirection
#debug_left int elevatorDirection
#srcline 400 ;    END_IF;
prgMain_L13:
#srcline 401 ;  END_IF;
prgMain_L5:
#srcline 402 ;  VisualizeQueue();
 LEA  __Instance__VisualizeQueue
 CAL  VisualizeQueue_L0
#srcline 403 ;  HandleDoors();
 LEA  __Instance__HandleDoors
 CAL  HandleDoors_L0
#srcline 404 ;  elevatorDirectionIndicator := elevatorDirection + 1;
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int 1
 ADD
 EXTW
 WR   elevatorDirectionIndicator
#debug_left int elevatorDirectionIndicator
#srcline 406 ;          anyDoorOpened := IsAnyDoorOpened();
 LEA  __Instance__IsAnyDoorOpened
 CAL  IsAnyDoorOpened_L0
 WR   anyDoorOpened
#debug_left bool anyDoorOpened
#srcline 407 ;  CASE switchCase OF
 LD   switchCase
#debug int switchCase
 EXTW 
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  prgMain_L15
#srcline 408 ;    0: 
#srcline 409 ;      timeDelayed := timePLC + waitTime;
 LD   timePLC
#debug int timePLC
 EXTW 
 LD   waitTime
#debug int waitTime
 EXTW 
 ADD
 EXTW
 WR   timeDelayed
#debug_left int timeDelayed
#srcline 410 ;      switchCase := 1;
 LD   int 1
 WR   switchCase
#debug_left int switchCase
#srcline 411 ;      waitTime := floorTravelTime;
 LD   floorTravelTime
#debug int floorTravelTime
 EXTW 
 WR   waitTime
#debug_left int waitTime
 JMP  prgMain_L14
prgMain_L15:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  prgMain_L16
#srcline 412 ;    1:
#srcline 413 ;      IF timeDelayed = timePLC THEN
 LD   timeDelayed
#debug int timeDelayed
 EXTW 
 LD   timePLC
#debug int timePLC
 EXTW 
 EQ
 JMC  prgMain_L17
#srcline 414 ;        IF NOT elevatorDirection = 0 THEN
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  prgMain_L19
#srcline 415 ;          IF NOT anyDoorOpened THEN
 LD   anyDoorOpened
#debug bool anyDoorOpened
 NEG
 JMC  prgMain_L21
#srcline 416 ;            // floor stop
#srcline 417 ;            IF HandleMovement() THEN
 LEA  __Instance__HandleMovement
 CAL  HandleMovement_L0
 JMC  prgMain_L23
#srcline 418 ;              // at floor queue[0] (first desired)
#srcline 419 ;              waitTime := doorsOpenTime;
 LD   doorsOpenTime
#debug int doorsOpenTime
 EXTW 
 WR   waitTime
#debug_left int waitTime
#srcline 420 ;              forceOpenCurrentElevatorFloorDoor := TRUE;
 LD   bool -1       ; true
 WR   forceOpenCurrentElevatorFloorDoor
#debug_left bool forceOpenCurrentElevatorFloorDoor
#srcline 421 ;            ELSE
 JMP  prgMain_L24
prgMain_L23:
#srcline 422 ;              forceOpenCurrentElevatorFloorDoor := FALSE;
 LD   bool 0       ; false
 WR   forceOpenCurrentElevatorFloorDoor
#debug_left bool forceOpenCurrentElevatorFloorDoor
#srcline 423 ;            END_IF;
prgMain_L24:
#srcline 424 ;            switchCase := 0;
 LD   int 0
 WR   switchCase
#debug_left int switchCase
#srcline 425 ;          ELSE
 JMP  prgMain_L22
prgMain_L21:
#srcline 426 ;            forceOpenCurrentElevatorFloorDoor := TRUE;
 LD   bool -1       ; true
 WR   forceOpenCurrentElevatorFloorDoor
#debug_left bool forceOpenCurrentElevatorFloorDoor
#srcline 427 ;            timeDelayed := timePLC + floorTravelTime;//
 LD   timePLC
#debug int timePLC
 EXTW 
 LD   floorTravelTime
#debug int floorTravelTime
 EXTW 
 ADD
 EXTW
 WR   timeDelayed
#debug_left int timeDelayed
#srcline 428 ;            switchCase := 2;
 LD   int 2
 WR   switchCase
#debug_left int switchCase
#srcline 429 ;          END_IF;
prgMain_L22:
#srcline 430 ;        ELSE
 JMP  prgMain_L20
prgMain_L19:
#srcline 431 ;          switchCase := 0;
 LD   int 0
 WR   switchCase
#debug_left int switchCase
#srcline 432 ;        END_IF;
prgMain_L20:
#srcline 433 ;      END_IF;
prgMain_L17:
 JMP  prgMain_L14
prgMain_L16:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  prgMain_L25
#srcline 434 ;    2:
#srcline 435 ;      IF timeDelayed = timePLC THEN
 LD   timeDelayed
#debug int timeDelayed
 EXTW 
 LD   timePLC
#debug int timePLC
 EXTW 
 EQ
 JMC  prgMain_L26
#srcline 436 ;        forceOpenCurrentElevatorFloorDoor := FALSE;
 LD   bool 0       ; false
 WR   forceOpenCurrentElevatorFloorDoor
#debug_left bool forceOpenCurrentElevatorFloorDoor
#srcline 437 ;        switchCase := 3;
 LD   int 3
 WR   switchCase
#debug_left int switchCase
#srcline 438 ;        timeDelayed := timePLC + floorTravelTime;
 LD   timePLC
#debug int timePLC
 EXTW 
 LD   floorTravelTime
#debug int floorTravelTime
 EXTW 
 ADD
 EXTW
 WR   timeDelayed
#debug_left int timeDelayed
#srcline 439 ;      END_IF;
prgMain_L26:
 JMP  prgMain_L14
prgMain_L25:
 LD   3
 LDY  P1__st__
 EQ  
 JMC  prgMain_L28
#srcline 440 ;    3:
#srcline 441 ;      IF timeDelayed = timePLC THEN
 LD   timeDelayed
#debug int timeDelayed
 EXTW 
 LD   timePLC
#debug int timePLC
 EXTW 
 EQ
 JMC  prgMain_L29
#srcline 442 ;        switchCase := 0;
 LD   int 0
 WR   switchCase
#debug_left int switchCase
#srcline 443 ;      END_IF;
prgMain_L29:
 JMP  prgMain_L14
prgMain_L28:
prgMain_L14:
#srcline 445 ;END_PROGRAM
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
