#srcfile 'C:\USERS\IGNáC\DOCUMENTS\PLC\WINTER_PLC\07_VYTAH\PRGMAIN.ST'

#defpou VisualizeQueue
  bool __fc__VisualizeQueue,
  int index
#reg VisualizeQueue  __Instance__VisualizeQueue


#defpou EnqueueFloor
  bool __fc__EnqueueFloor,
  int floorToEnqueue,
  int index
#reg EnqueueFloor  __Instance__EnqueueFloor


#defpou ShiftQueueLeft
  bool __fc__ShiftQueueLeft,
  int index,
  int nextIndex,
  int temp
#reg ShiftQueueLeft  __Instance__ShiftQueueLeft


#defpou DequeueFloor
  int __fc__DequeueFloor,
  int dequeuedFloor
#reg DequeueFloor  __Instance__DequeueFloor


#defpou IsFloorAlreadyEnqueued
  bool __fc__IsFloorAlreadyEnqueued,
  int index,
  int floor
#reg IsFloorAlreadyEnqueued  __Instance__IsFloorAlreadyEnqueued


#defpou CloseAllDoors
  bool __fc__CloseAllDoors,
  int index
#reg CloseAllDoors  __Instance__CloseAllDoors


#defpou HandleDoors
  bool __fc__HandleDoors
#reg HandleDoors  __Instance__HandleDoors


#defpou ResetAllButtons
  bool __fc__ResetAllButtons,
  int index
#reg ResetAllButtons  __Instance__ResetAllButtons


#defpou HandleFloorSelection
  bool __fc__HandleFloorSelection
#reg HandleFloorSelection  __Instance__HandleFloorSelection


#defpou IsAnyButtonPressed
  bool __fc__IsAnyButtonPressed,
  int index
#reg IsAnyButtonPressed  __Instance__IsAnyButtonPressed


#defpou HandleButtons
  bool __fc__HandleButtons,
  int index
#reg HandleButtons  __Instance__HandleButtons


#defpou HandleMovement
  bool __fc__HandleMovement
#reg HandleMovement  __Instance__HandleMovement


#defpou IsAnyObstaclePresent
  bool __fc__IsAnyObstaclePresent,
  int index
#reg IsAnyObstaclePresent  __Instance__IsAnyObstaclePresent


#defpou HandleStopConditions
  bool __fc__HandleStopConditions
#reg HandleStopConditions  __Instance__HandleStopConditions


#defpou prgMain
  int index

 
#srcfile 'C:\USERS\IGNáC\DOCUMENTS\PLC\WINTER_PLC\07_VYTAH\PRGMAIN.ST'
#pou VisualizeQueue
#srcline 2 ;FUNCTION VisualizeQueue : BOOL

#struct VisualizeQueue__temp__
  int P0__st__,
  string[82] PS0__st__,
  string[82] PSC__st__
#data byte _str_VisualizeQueue_0 = 
  '',0
#data byte _str_VisualizeQueue_1 = 
  ';',0
P     61
VisualizeQueue_L0:
 LINK __SizeOf(VisualizeQueue__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__VisualizeQueue
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 6 ;  stringQueueRepresentation := '';
 LD   0   ; null string
 LEA  stringQueueRepresentation
 WRI  
 LEA  stringQueueRepresentation
 LD   80
 DST    ; Level 1
 LEA  _str_VisualizeQueue_0
 SCON 
#debug_left string stringQueueRepresentation
 PDST   ; Level 1
#srcline 7 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
VisualizeQueue_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  VisualizeQueue_L2
 DBG  
#srcline 8 ;    stringQueueRepresentation := stringQueueRepresentation + ';' + INT_TO_STRING(queue[index]);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  stringQueueRepresentation
#debug string stringQueueRepresentation
 SCON 
 LEA  _str_VisualizeQueue_1
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   80
 DST    ; Level 2
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 SCNV $0B30;  IEC_INT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEA  stringQueueRepresentation
 WRI  
 LEA  stringQueueRepresentation
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string stringQueueRepresentation
 PDST   ; Level 1
#srcline 9 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  VisualizeQueue_L1
VisualizeQueue_L2:
 NOP  -1
#srcline 10 ;END_FUNCTION
 PRV  
 LDX  __fc__VisualizeQueue
 ULNK
RET
E     61
#endpou 

#pou EnqueueFloor
#srcline 12 ;FUNCTION EnqueueFloor : BOOL

#struct EnqueueFloor__temp__
  int P0__st__
P     61
EnqueueFloor_L0:
 LINK __SizeOf(EnqueueFloor__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__EnqueueFloor
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 20 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
EnqueueFloor_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  EnqueueFloor_L2
 DBG  
#srcline 21 ;    IF queue[index] = queueDefaultValue THEN
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 EQ
 JMC  EnqueueFloor_L3
#srcline 22 ;      queue[index] := floorToEnqueue;
 LDX  floorToEnqueue
#debug int floorToEnqueue
 EXTW 
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index]
#srcline 23 ;      index := index + 100; // break
 LDX  index
#debug int index
 EXTW 
 LD   int 100
 ADD
 EXTW
 WRX  index
#debug_left int index
#srcline 24 ;    END_IF;
EnqueueFloor_L3:
#srcline 25 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  EnqueueFloor_L1
EnqueueFloor_L2:
 NOP  -1
#srcline 26 ;END_FUNCTION
 PRV  
 LDX  __fc__EnqueueFloor
 ULNK
RET
E     61
#endpou 

#pou ShiftQueueLeft
#srcline 28 ;FUNCTION ShiftQueueLeft : BOOL

#struct ShiftQueueLeft__temp__
  int P0__st__
P     61
ShiftQueueLeft_L0:
 LINK __SizeOf(ShiftQueueLeft__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__ShiftQueueLeft
 WRX  index
 WRX  nextIndex
 WRX  temp
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 34 ;  FOR index := 0 TO queueSize - 2 DO // - 2 because not for last element
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 2
 SUB
 EXTW
 WRY  P0__st__
ShiftQueueLeft_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  ShiftQueueLeft_L2
 DBG  
#srcline 35 ;    nextIndex := index + 1;
 LDX  index
#debug int index
 EXTW 
 LD   int 1
 ADD
 EXTW
 WRX  nextIndex
#debug_left int nextIndex
#srcline 36 ;    temp := queue[index];
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 WRX  temp
#debug_left int temp
#srcline 37 ;    queue[index] := queue[nextIndex];
 LEA  queue
 LDX  nextIndex
#debug int nextIndex
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[nextIndex]
 EXTW 
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index]
#srcline 38 ;    queue[nextIndex] := temp;
 LDX  temp
#debug int temp
 EXTW 
 LEA  queue
 LDX  nextIndex
#debug int nextIndex
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[nextIndex]
#srcline 39 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  ShiftQueueLeft_L1
ShiftQueueLeft_L2:
 NOP  -1
#srcline 40 ;END_FUNCTION
 PRV  
 LDX  __fc__ShiftQueueLeft
 ULNK
RET
E     61
#endpou 

#pou DequeueFloor
#srcline 42 ;FUNCTION DequeueFloor : INT
P     61
DequeueFloor_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__DequeueFloor
 WRX  dequeuedFloor
; End initialize - variables
#srcline 45 ;  END_VAR;
#srcline 47 ;  dequeuedFloor := queue[0];
 LD   queue[0]
#debug int queue[0]
 EXTW 
 WRX  dequeuedFloor
#debug_left int dequeuedFloor
#srcline 48 ;  queue[0] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 WR   queue[0]
#debug_left int queue[0]
#srcline 49 ;  ShiftQueueLeft();
 LEA  __Instance__ShiftQueueLeft
 CAL  ShiftQueueLeft_L0
#srcline 50 ;  DequeueFloor := dequeuedFloor;
 LDX  dequeuedFloor
#debug int dequeuedFloor
 EXTW 
 WRX  __fc__DequeueFloor
#debug_left int DequeueFloor
#srcline 51 ;END_FUNCTION
 PRV  
 LDX  __fc__DequeueFloor
 EXTW 
 ULNK
RET
E     61
#endpou 

#pou IsFloorAlreadyEnqueued
#srcline 53 ;FUNCTION IsFloorAlreadyEnqueued : BOOL

#struct IsFloorAlreadyEnqueued__temp__
  int P0__st__
P     61
IsFloorAlreadyEnqueued_L0:
 LINK __SizeOf(IsFloorAlreadyEnqueued__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__IsFloorAlreadyEnqueued
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 61 ;  FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
IsFloorAlreadyEnqueued_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  IsFloorAlreadyEnqueued_L2
 DBG  
#srcline 62 ;    IF queue[index] = floor THEN
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
#debug int queue[index]
 EXTW 
 LDX  floor
#debug int floor
 EXTW 
 EQ
 JMC  IsFloorAlreadyEnqueued_L3
#srcline 63 ;      IsFloorAlreadyEnqueued := TRUE;
 LD   bool -1       ; true
 WRX  __fc__IsFloorAlreadyEnqueued
#debug_left bool IsFloorAlreadyEnqueued
#srcline 64 ;      index := 1000;
 LD   int 1000
 WRX  index
#debug_left int index
#srcline 65 ;    END_IF;
IsFloorAlreadyEnqueued_L3:
#srcline 66 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  IsFloorAlreadyEnqueued_L1
IsFloorAlreadyEnqueued_L2:
 NOP  -1
#srcline 67 ;  
#srcline 68 ;END_FUNCTION
 PRV  
 LDX  __fc__IsFloorAlreadyEnqueued
 ULNK
RET
E     61
#endpou 

#pou CloseAllDoors
#srcline 72 ;FUNCTION CloseAllDoors : BOOL

#struct CloseAllDoors__temp__
  int P0__st__
P     61
CloseAllDoors_L0:
 LINK __SizeOf(CloseAllDoors__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__CloseAllDoors
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 76 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
CloseAllDoors_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  CloseAllDoors_L2
 DBG  
#srcline 77 ;    elevatorDoorsOpened[index] := FALSE;
 LD   bool 0       ; false
 LEA  elevatorDoorsOpened
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[index]
#srcline 78 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  CloseAllDoors_L1
CloseAllDoors_L2:
 NOP  -1
#srcline 79 ;END_FUNCTION
 PRV  
 LDX  __fc__CloseAllDoors
 ULNK
RET
E     61
#endpou 

#pou HandleDoors
#srcline 81 ;FUNCTION HandleDoors : BOOL
P     61
HandleDoors_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleDoors
; End initialize - variables
#srcline 82 ;  IF forceOpenCurrentElevatorFloorDoor THEN
 LD   forceOpenCurrentElevatorFloorDoor
#debug bool forceOpenCurrentElevatorFloorDoor
 JMC  HandleDoors_L1
#srcline 83 ;    elevatorDoorsOpened[elevatorFloor - 1] := TRUE;
 LD   bool -1       ; true
 LEA  elevatorDoorsOpened
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[elevatorFloor-1]
#srcline 84 ;  ELSIF elevatorDirection = 0 THEN
 JMP  HandleDoors_L2
HandleDoors_L1:
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int 0
 EQ
 JMC  HandleDoors_L3
#srcline 85 ;    // open doors of the floor the elevator is at
#srcline 86 ;    CloseAllDoors();
 LEA  __Instance__CloseAllDoors
 CAL  CloseAllDoors_L0
#srcline 87 ;    elevatorDoorsOpened[elevatorFloor] := TRUE;
 LD   bool -1       ; true
 LEA  elevatorDoorsOpened
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorDoorsOpened[elevatorFloor]
#srcline 88 ;  END_IF;
 JMP  HandleDoors_L2
HandleDoors_L3:
HandleDoors_L2:
#srcline 89 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleDoors
 ULNK
RET
E     61
#endpou 

#pou ResetAllButtons
#srcline 92 ;FUNCTION ResetAllButtons : BOOL

#struct ResetAllButtons__temp__
  int P0__st__
P     61
ResetAllButtons_L0:
 LINK __SizeOf(ResetAllButtons__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__ResetAllButtons
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 96 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
ResetAllButtons_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  ResetAllButtons_L2
 DBG  
#srcline 97 ;    elevatorButtonsPressed[index] := FALSE;
 LD   bool 0       ; false
 LEA  elevatorButtonsPressed
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool elevatorButtonsPressed[index]
#srcline 98 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  ResetAllButtons_L1
ResetAllButtons_L2:
 NOP  -1
#srcline 99 ;END_FUNCTION
 PRV  
 LDX  __fc__ResetAllButtons
 ULNK
RET
E     61
#endpou 

#pou HandleFloorSelection
#srcline 101 ;FUNCTION HandleFloorSelection : BOOL
P     61
HandleFloorSelection_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleFloorSelection
; End initialize - variables
#srcline 102 ;  IF NOT elevatorFloor = targetFloor AND NOT IsFloorAlreadyEnqueued(targetFloor) THEN
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 LD   targetFloor
#debug int targetFloor
 EXTW 
 EQ
 NEG
 NXT
 LD   targetFloor
#debug int targetFloor
 EXTW 
 WR   __Instance__IsFloorAlreadyEnqueued~floor
#debug_left int __Instance__IsFloorAlreadyEnqueued~floor
 PRV
 LEA  __Instance__IsFloorAlreadyEnqueued
 CAL  IsFloorAlreadyEnqueued_L0
 NEG
 AND
 JMC  HandleFloorSelection_L1
#srcline 103 ;    floorDifference := elevatorFloor - targetFloor;
 LD   elevatorFloor
#debug int elevatorFloor
 EXTW 
 LD   targetFloor
#debug int targetFloor
 EXTW 
 SUB
 EXTW
 WR   floorDifference
#debug_left int floorDifference
#srcline 104 ;    IF floorDifference > 0 THEN
 LD   floorDifference
#debug int floorDifference
 EXTW 
 LD   int 0
 GTS
 JMC  HandleFloorSelection_L3
#srcline 105 ;      elevatorDirection := -1;
 LD   int -1
 WR   elevatorDirection
#debug_left int elevatorDirection
#srcline 106 ;      EnqueueFloor(targetFloor);
 NXT
 LD   targetFloor
#debug int targetFloor
 EXTW 
 WR   __Instance__EnqueueFloor~floorToEnqueue
#debug_left int __Instance__EnqueueFloor~floorToEnqueue
 PRV
 LEA  __Instance__EnqueueFloor
 CAL  EnqueueFloor_L0
#srcline 107 ;      floorSetAsElevStop[targetFloor] := TRUE;
 LD   bool -1       ; true
 LEA  floorSetAsElevStop
 LD   targetFloor
#debug int targetFloor
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool floorSetAsElevStop[targetFloor]
#srcline 108 ;    ELSIF floorDifference < 0 THEN
 JMP  HandleFloorSelection_L4
HandleFloorSelection_L3:
 LD   floorDifference
#debug int floorDifference
 EXTW 
 LD   int 0
 LTS
 JMC  HandleFloorSelection_L5
#srcline 109 ;      elevatorDirection := 1;
 LD   int 1
 WR   elevatorDirection
#debug_left int elevatorDirection
#srcline 110 ;      EnqueueFloor(targetFloor);
 NXT
 LD   targetFloor
#debug int targetFloor
 EXTW 
 WR   __Instance__EnqueueFloor~floorToEnqueue
#debug_left int __Instance__EnqueueFloor~floorToEnqueue
 PRV
 LEA  __Instance__EnqueueFloor
 CAL  EnqueueFloor_L0
#srcline 111 ;      floorSetAsElevStop[targetFloor] := TRUE;
 LD   bool -1       ; true
 LEA  floorSetAsElevStop
 LD   targetFloor
#debug int targetFloor
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 WRIB 
#debug_left bool floorSetAsElevStop[targetFloor]
#srcline 112 ;    END_IF;
 JMP  HandleFloorSelection_L4
HandleFloorSelection_L5:
HandleFloorSelection_L4:
#srcline 113 ;    
#srcline 114 ;  ELSE
 JMP  HandleFloorSelection_L2
HandleFloorSelection_L1:
#srcline 115 ;    elevatorDirectionIndicator := 1;
 LD   int 1
 WR   elevatorDirectionIndicator
#debug_left int elevatorDirectionIndicator
#srcline 116 ;  END_IF;
HandleFloorSelection_L2:
#srcline 117 ;  
#srcline 118 ;  floorDifference := ABS(floorDifference);
 LD   floorDifference
#debug int floorDifference
 EXTW 
 ABSL
 WR   floorDifference
#debug_left int floorDifference
#srcline 119 ;  ResetAllButtons();
 LEA  __Instance__ResetAllButtons
 CAL  ResetAllButtons_L0
#srcline 120 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleFloorSelection
 ULNK
RET
E     61
#endpou 

#pou IsAnyButtonPressed
#srcline 122 ;FUNCTION IsAnyButtonPressed : BOOL

#struct IsAnyButtonPressed__temp__
  int P0__st__
P     61
IsAnyButtonPressed_L0:
 LINK __SizeOf(IsAnyButtonPressed__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__IsAnyButtonPressed
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 125 ;  END_VAR;
#srcline 126 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
IsAnyButtonPressed_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  IsAnyButtonPressed_L2
 DBG  
#srcline 127 ;    IF elevatorButtonsPressed[index] THEN
 LEA  elevatorButtonsPressed
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 LDIB 
#debug bool elevatorButtonsPressed[index]
 JMC  IsAnyButtonPressed_L3
#srcline 128 ;      anyFloorButtonPressed := TRUE;
 LD   bool -1       ; true
 WR   anyFloorButtonPressed
#debug_left bool anyFloorButtonPressed
#srcline 129 ;      IsAnyButtonPressed := TRUE;
 LD   bool -1       ; true
 WRX  __fc__IsAnyButtonPressed
#debug_left bool IsAnyButtonPressed
#srcline 130 ;    END_IF;
IsAnyButtonPressed_L3:
#srcline 131 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  IsAnyButtonPressed_L1
IsAnyButtonPressed_L2:
 NOP  -1
#srcline 132 ;  
#srcline 133 ;END_FUNCTION
 PRV  
 LDX  __fc__IsAnyButtonPressed
 ULNK
RET
E     61
#endpou 

#pou HandleButtons
#srcline 135 ;FUNCTION HandleButtons : BOOL

#struct HandleButtons__temp__
  int P0__st__
P     61
HandleButtons_L0:
 LINK __SizeOf(HandleButtons__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleButtons
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 140 ;  IsAnyButtonPressed();
 LEA  __Instance__IsAnyButtonPressed
 CAL  IsAnyButtonPressed_L0
#srcline 142 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
HandleButtons_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  HandleButtons_L2
 DBG  
#srcline 143 ;    IF elevatorButtonsPressed[index] THEN
 LEA  elevatorButtonsPressed
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 LDIB 
#debug bool elevatorButtonsPressed[index]
 JMC  HandleButtons_L3
#srcline 144 ;      targetFloor := index;
 LDX  index
#debug int index
 EXTW 
 WR   targetFloor
#debug_left int targetFloor
#srcline 145 ;      HandleFloorSelection();
 LEA  __Instance__HandleFloorSelection
 CAL  HandleFloorSelection_L0
#srcline 146 ;    END_IF;
HandleButtons_L3:
#srcline 147 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  HandleButtons_L1
HandleButtons_L2:
 NOP  -1
#srcline 148 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleButtons
 ULNK
RET
E     61
#endpou 

#pou HandleMovement
#srcline 151 ;FUNCTION HandleMovement : BOOL
P     61
HandleMovement_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleMovement
; End initialize - variables
#srcline 152 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleMovement
 ULNK
RET
E     61
#endpou 

#pou IsAnyObstaclePresent
#srcline 154 ;FUNCTION IsAnyObstaclePresent : BOOL

#struct IsAnyObstaclePresent__temp__
  int P0__st__
P     61
IsAnyObstaclePresent_L0:
 LINK __SizeOf(IsAnyObstaclePresent__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__IsAnyObstaclePresent
 WRX  index
; End initialize - variables
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 159 ;  anyObstacleDetected := FALSE;
 LD   bool 0       ; false
 WR   anyObstacleDetected
#debug_left bool anyObstacleDetected
#srcline 160 ;  FOR index := 0 TO highestFloor - 1 DO
 LD   int 0
 WRX  index
 LD   highestFloor
#debug int highestFloor
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
IsAnyObstaclePresent_L1:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  IsAnyObstaclePresent_L2
 DBG  
#srcline 161 ;    IF obstaclesBlockingDoors[index] OR obstacleElevator THEN
 LEA  obstaclesBlockingDoors
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 ADD     ; + offset 
 LDIB 
#debug bool obstaclesBlockingDoors[index]
 LD   obstacleElevator
#debug bool obstacleElevator
 OR  
 JMC  IsAnyObstaclePresent_L3
#srcline 162 ;      anyObstacleDetected := TRUE;
 LD   bool -1       ; true
 WR   anyObstacleDetected
#debug_left bool anyObstacleDetected
#srcline 163 ;    END_IF;
IsAnyObstaclePresent_L3:
#srcline 164 ;  END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  IsAnyObstaclePresent_L1
IsAnyObstaclePresent_L2:
 NOP  -1
#srcline 165 ;END_FUNCTION
 PRV  
 LDX  __fc__IsAnyObstaclePresent
 ULNK
RET
E     61
#endpou 

#pou HandleStopConditions
#srcline 167 ;FUNCTION HandleStopConditions : BOOL
P     61
HandleStopConditions_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__HandleStopConditions
; End initialize - variables
#srcline 168 ;  stopSignActivated := anyObstacleDetected OR elevatorButtonStopPressed;
 LD   anyObstacleDetected
#debug bool anyObstacleDetected
 LD   elevatorButtonStopPressed
#debug bool elevatorButtonStopPressed
 OR  
 WR   stopSignActivated
#debug_left bool stopSignActivated
#srcline 169 ;END_FUNCTION
 PRV  
 LDX  __fc__HandleStopConditions
 ULNK
RET
E     61
#endpou 

#pou prgMain
#srcline 171 ;PROGRAM prgMain

#struct prgMain__temp__
  int P0__st__
P     61
prgMain_L0:
 LINK __SizeOf(prgMain__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 182 ;  IsAnyObstaclePresent();
 LEA  __Instance__IsAnyObstaclePresent
 CAL  IsAnyObstaclePresent_L0
#srcline 183 ;  HandleStopConditions();
 LEA  __Instance__HandleStopConditions
 CAL  HandleStopConditions_L0
#srcline 184 ;  HandleButtons();
 LEA  __Instance__HandleButtons
 CAL  HandleButtons_L0
#srcline 185 ;  elevatorDirectionIndicator := elevatorDirection + 1;
 LD   elevatorDirection
#debug int elevatorDirection
 EXTW 
 LD   int 1
 ADD
 EXTW
 WR   elevatorDirectionIndicator
#debug_left int elevatorDirectionIndicator
#srcline 186 ;  //VisualizeQueue();
#srcline 187 ;  (* configuration *)
#srcline 188 ;  IF NOT configured THEN
 LD   configured
#debug bool configured
 NEG
 JMC  prgMain_L1
#srcline 189 ;    FOR index := 0 TO queueSize - 1 DO
 LD   int 0
 WRX  index
 LD   queueSize
#debug int queueSize
 EXTW 
 LD   int 1
 SUB
 EXTW
 WRY  P0__st__
prgMain_L3:
 LDX  index
 EXTW 
 LDY  P0__st__
 EXTW 
 GTS  
 JMD  prgMain_L4
 DBG  
#srcline 190 ;      queue[index] := queueDefaultValue;
 LD   queueDefaultValue
#debug int queueDefaultValue
 EXTW 
 LEA  queue
 LDX  index
#debug int index
 EXTW 
 RCHK 4   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left int queue[index]
#srcline 191 ;    END_FOR;
 LDX  index
 LD   1
 ADD  
 EXTW 
 WRX  index
 JMP  prgMain_L3
prgMain_L4:
 NOP  -1
#srcline 192 ;    elevatorDoorsOpened[0] := TRUE;
 LD   bool -1       ; true
 WR   elevatorDoorsOpened[0]
#debug_left bool elevatorDoorsOpened[0]
#srcline 193 ;    
#srcline 194 ;    configured := TRUE;
 LD   bool -1       ; true
 WR   configured
#debug_left bool configured
#srcline 195 ;  END_IF;
prgMain_L1:
#srcline 196 ;  
#srcline 198 ;END_PROGRAM
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
